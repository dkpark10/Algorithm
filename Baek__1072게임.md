# 백준 1027번 게임
## 문제

> 김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다.
형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 
누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다.
의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 
그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.
이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 
하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 
예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.
게임 기록은 다음과 같이 생겼다. </br>
게임 횟수 : X
이긴 게임 : Y (Z %)
Z는 형택이의 승률이다. 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z = 88이다.
X와 Y가 주어졌을 때, 형택이가 게임을 몇 판 더해야 Z가 변하는지 구하는 프로그램을 작성하시오.
각 줄에 X와 Y가 주어진다. X는 1,000,000,000보다 작거나 같은 자연수이고, 
Y는 0보다 크거나 같고, X보다 작거나 같은 자연수이다.
## 입력
> 10 8</br>
  100 80</br>
## 출력
> 1</br>
  6
```c++
#include<cstdio>
#include<algorithm>
#include<iostream>
#define ll long long
ll MAX = 1000000000;

ll Game(ll x, ll y)
{
    ll z, temp;
    ll left = 0, mid, right = MAX;
    z = y * 100 / x;

    if(z >= 99) return -1;                    // 여기 잘못 이해해 개삽질... 진짜 눈물난다 금방풀 수 있는건데..
    
    while(left <= right){

        mid = (left + right) / 2;
        temp = (y + mid) * 100 / (x + mid);   // mid번 게임해서 승률 구함 

        if(z < temp) right = mid -1;          
        else left = mid + 1;
    }
    return left;                              // 승률이 변하는 최소값을 출력
}

int main(void)
{
    ll X,Y;
    scanf("%lld %lld", &X, &Y);
    printf("%lld\n",Game(X,Y));

    return 0;
}
```
## 풀이
> 문제를 잘못 이해해서 너무 빡친 문제
Z가 변하지 않는 경우의 수를 최대값인 10억번 게임까지 해서 안변하는 경우로 생각했다........ 분명틀린게 없는데 
결국 남의 블로그 보고 Z가 안변하는 경우의 수를 내가 완전 잘못 이해했구나 생각.........
Z가 안변하는 경우는 승률이 99%이상일 때
98%는 99%가 될 수 있어도
99%는 절대로 100%가 될 수 없다. 이거 잘못이해해서 삽질ㅜㅜ</br>
본론으로 들어가자면
승률이 변하는 경우는
(X + ans) * 100 / (Y + ans)를 
(X + ans++) * 100 / (Y + ans++)를 
이렇게 증감연산해서 풀 수 있다. 
그러나...
최대값이 10억이기 때문에 값이 극단적으로 커지면 연산이 많아지고
당연히 시간초과가 뜬다. 
그러므로 이분탐색으로 푼다.
이분탐색으로 값을 찾아나가면서 Z가 변하는 경우인 값을 리턴
