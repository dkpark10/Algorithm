# 백준 1149번 RGB거리 

## 문제
RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.</br>
집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 </br>
칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.</br>
</br>
1번 집의 색은 2번 집의 색과 같지 않아야 한다.</br>
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.</br>
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.</br>

## 입력
> 3</br>
26 40 83</br>
49 60 57</br>
13 89 99</br>

## 출력
> 96</br>

## 코드
```c++
#include<iostream>
using namespace std;
int main(void)
{
    int N,h[1001][3],d[1001][3];
    cin >> N;
    for(int i=1; i<= N; i++)
        cin >> h[i][0] >> h[i][1] >> h[i][2];
    d[1][0] = h[1][0];
    d[1][1] = h[1][1];
    d[1][2] = h[1][2];
    for(int i=2; i<=N; i++){
        d[i][0]= min(d[i-1][1], d[i-1][2]) + h[i][0];
        d[i][1]= min(d[i-1][0], d[i-1][2]) + h[i][1];
        d[i][2]= min(d[i-1][0], d[i-1][1]) + h[i][2];
    }
    cout << min(d[N][0] ,min(d[N][1], d[N][2])) << endl;
    return 0;
}
```

## 풀이
다이나믹 프로그래밍으로 푼다 ...........................</br>
디피 배열에서 열에 해당하는 0,1,2를 RGB로 설정하고 </br>
d[i][0] = 현재 인덱스에서 빨강으로 칠할 때 </br>
d[i][1] = 현재 인덱스에서 초록으로 칠할 때 </br>
d[i][2] = 현재 인덱스에서 파랑으로 칠할 때 </br>
즉 점화식을 세워보면 간단하다. 예를 들어 현재 인덱스를 빨강으로 칠하고자 할 때</br>
</br>
**d[현재인덱스][0] = 전 마을에서 d[i - 1][1]초록 vs d[i - 1][2]파랑 **
