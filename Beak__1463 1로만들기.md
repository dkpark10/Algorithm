# 백준 1463번 1로 만들기 

## 문제
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</br>
1. X가 3으로 나누어 떨어지면, 3으로 나눈다.</br>
2. X가 2로 나누어 떨어지면, 2로 나눈다.</br>
3. 1을 뺀다.</br>

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</br>

## 입력
> 9
## 출력
> 2
## 코드
```c++
#include <cstdio>
#include <iostream>
#include <cstring>
#define MIN(x,y) ((x) < (y)? (x): (y))
#pragma warning(disable:4996)
using namespace std;

int main(void)
{
	int N, dp[1000001];
	scanf("%d", &N);
	dp[0] = 0;
	dp[1] = 0;

	for (int n = 2; n <= N; n++) {

		dp[n] = dp[n - 1] + 1;
		if (n % 2 == 0) dp[n] = MIN(dp[n], dp[n / 2] + 1);
		if (n % 3 == 0) dp[n] = MIN(dp[n], dp[n / 3] + 1); # 여기서 주의 else if를 쓰면 안댐 2나 3의 공배수일 수 있으므로          
	                                                     # 누가 봐도 3으로 나눈 횟수가 연산횟수가 적을테니 
	}
	printf("%d", dp[N]);

	return 0;
}
```
## 풀이
이제보니 이 문제 전나게 쉽다 ㅋ </br>
0이나 1은 어차피 0이고 2부터 시작한다 문제의 3번조건 1을 뺀다의 조건 때문에 무적권 전에 있는 숫자보다 최소연산횟수가 1이 더 높다 </br>
당연한거다 근데 그 숫자가 2나 3의 배수일 수 있으므로 앞서 1을 더한 최소연산횟수와 2나 3으로 나눈 값의 최소연산횟수 + 1가 비교해준다 </br>
더 작은값을 넣으면 댐 ^^ 지금 푼건 bottom - top 방식이다 나중에 top - bottom방식으로 또 풀어야지 ㅋ 
