# 백준 7579번 앱

우리는 스마트폰을 사용하면서 여러 가지 앱(App)을 실행하게 된다. 대개의 경우 화면에 보이는 ‘실행 중’인 앱은 </br>
하나뿐이지만 보이지 않는 상태로 많은 앱이 '활성화'되어 있다. 앱들이 활성화 되어 있다는 것은 화면에 보이지 </br>
않더라도 메인 메모리에 직전의 상태가 기록되어 있는 것을 말한다. 현재 실행 중이 아니더라도 이렇게 메모리에</br>
남겨두는 이유는 사용자가 이전에 실행하던 앱을 다시 불러올 때에 직전의 상태를 메인 메모리로부터 읽어 들여 실행 준비를 빠르게 마치기 위해서이다.</br>
하지만 스마트폰의 메모리는 제한적이기 때문에 한번이라도 실행했던 모든 앱을 활성화된 채로 메인 메모리에 </br>
남겨두다 보면 메모리 부족 상태가 오기 쉽다. 새로운 앱을 실행시키기 위해 필요한 메모리가 부족해지면 </br>
스마트폰의 운영체제는 활성화 되어 있는 앱들 중 몇 개를 선택하여 메모리로부터 삭제하는 수밖에 없다.</br>
이러한 과정을 앱의 ‘비활성화’라고 한다.</br>
메모리 부족 상황에서 활성화 되어 있는 앱들을 무작위로 필요한 메모리만큼 비활성화 하는 것은 좋은 방법이</br>
아니다. 비활성화된 앱들을 재실행할 경우 그만큼 시간이 더 필요하기 때문이다. 여러분은 이러한 앱의 비활성화</br>
문제를 스마트하게 해결하기 위한 프로그램을 작성해야 한다</br>
현재 N개의 앱, A1, ..., AN이 활성화 되어 있다고 가정하자. 이들 앱 Ai는 각각 mi 바이트만큼의 메모리를</br>
사용하고 있다. 또한, 앱 Ai를 비활성화한 후에 다시 실행하고자 할 경우, 추가적으로 들어가는 비용(시간 등)을</br>
수치화 한 것을 ci 라고 하자. 이러한 상황에서 사용자가 새로운 앱 B를 실행하고자 하여, 추가로 M 바이트의</br>
메모리가 필요하다고 하자. 즉, 현재 활성화 되어 있는 앱 A1, ..., AN 중에서 몇 개를 비활성화 하여 M 바이트</br>
이상의 메모리를 추가로 확보해야 하는 것이다. 여러분은 그 중에서 비활성화 했을 경우의 비용 ci의 합을</br>
최소화하여 필요한 메모리 M 바이트를 확보하는 방법을 찾아야 한다.</br>

## 코드
```c++
#include <cstdio>
#include <cstring>
#include <iostream>
int N, M, m[101], c[101], dp[10001];
int main(){
    scanf("%d %d", &N, &M);
    memset(dp, -1, sizeof(dp));
    for(int i = 0; i < N; i++)scanf("%d", &m[i]);
    for(int i = 0; i < N; i++)scanf("%d", &c[i]);
    for(int i = 0; i < N; i++){
        int cost = c[i];
        for(int j = 10000; j >= cost; j--){
            if(dp[j - cost] == -1)continue;
            if(dp[j - cost] + m[i] > dp[j])dp[j] = dp[j - cost] + m[i];
        }
        if(dp[cost] < m[i])dp[cost] = m[i];
    }
    for(int i = 0; i < 10001; i++){
        if(dp[i] >= M){
            printf("%d", i);
            break;
        }
    }
}
```

## 풀이

**배낭문제** </br>
디피 점화식은 비활성화 비용이 1 ~ 10000 일 때 이 비활성화 비용으로 </br>
얼마만큼의 메모리를 최대로 활성화할 수 있는지를 점화식으로 세운다. </br>

> dp[비활성화비용] = dp[i번째 앱을 비활성화 했을 경우 , i 번쨰 앱을 활성화 했을경우);

앱의 갯수 N번 반복하면서 N개의 앱을 활성화, 비활성화 하며 메모리를 </br>
다이나믹 프로그래밍으로 구한다. </br>

항상 디피 문제에 있어서 이걸 선택 or 선택하지 않은 두가지의 경우를 다 고려해야 할 경우
무조건 **다이나믹 프로그래밍** 으로 푼다.!!!!!!!!!!!!!!
