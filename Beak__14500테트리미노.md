# 백준 14500번 테트리미노

## 문제

폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다. </br>
</br>
1.정사각형은 서로 겹치면 안 된다.</br>
2.도형은 모두 연결되어 있어야 한다.</br>
3.정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.</br>
</br>
정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다. </br>

![image](https://user-images.githubusercontent.com/43857226/79108387-3039d000-7db1-11ea-84d2-7da4e8f6274b.png)

아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.
테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.
테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.

## 입력

> 5 5</br>
1 2 3 4 5</br>
5 4 3 2 1</br>
2 3 4 5 6</br>
6 5 4 3 2</br>
1 2 1 2 1</br>

## 출력

> 19 </br>

## 코드

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int block[19][4][2] = {
    {{0, 0}, {0, 1}, {0, 2}, {0, 3}},
    {{0, 0}, {1, 0}, {2, 0}, {3, 0}},
    {{0, 0}, {0, 1}, {1, 0}, {1, 1}},
    {{0, 0}, {1, 0}, {2, 0}, {2, 1}},
    {{0, 0}, {0, 1}, {0, 2}, {-1, 2}},
    {{0, 0}, {0, 1}, {1, 1}, {2, 1}},
    {{0, 0}, {0, 1}, {0, 2}, {1, 0}},
    {{0, 0}, {1, 0}, {2, 0}, {2, -1}},
    {{0, 0}, {0, 1}, {0, 2}, {-1, 0}},
    {{0, 0}, {0, 1}, {1, 0}, {2, 0}},
    {{0, 0}, {0, 1}, {0, 2}, {1, 2}},
    {{0, 0}, {1, 0}, {1, 1}, {2, 1}},
    {{0, 0}, {0, 1}, {-1, 1}, {-1, 2}},
    {{0, 0}, {1, 0}, {1, -1}, {2, -1}},
    {{0, 0}, {0, 1}, {1, 1}, {1, 2}},
    {{0, 0}, {0, 1}, {0, 2}, {1, 1}},
    {{0, 0}, {0, 1}, {0, 2}, {-1, 1}},
    {{0, 0}, {1, 0}, {2, 0}, {1, -1}},
    {{0, 0}, {1, 0}, {2, 0}, {1, 1}}};
int N, M,ans = 0, map[500][500];
int Go(int idx, int y, int x)
{
    int ret = 0;
    for(int i=0; i<4; i++){
        int ny = y + block[idx][i][0];
        int nx = x + block[idx][i][1];
        if (ny < 0 || nx < 0 || ny >= N || nx >= M) return -1;
        ret += map[ny][nx];
    }
    return ret;
}
int main(void)
{
    scanf("%d %d",&N, &M);
    for(int i=0; i<N; i++)
        for(int j=0; j<M; j++)
            scanf("%d",&map[i][j]);
    for(int i=0; i< 19; i++){
        for(int j=0; j< N; j++){
            for(int k=0; k<M; k++){
                int temp = Go(i,j,k);
                if(temp == -1) continue;
                ans = max(ans, temp);
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

## 풀이

블록 모양의 모오오옹오오오오옹든 경우의 수를 배열에 저장하고 풀었다. </br>
