# 백준 2208번 보석줍기

## 문제

화영이는 고대 유적을 탐사하던 도중 보석을 발견했다. 유적 속에는 N(1≤N≤100,000)개의 보석들이 일렬로 놓여 있었다. </br>
각각의 보석의 가치는 다를 수 있기 때문에, 화영이는 가급적 많은 이득을 얻을 수 있도록 보석을 가져가려 한다. 이때, 다음 세 가지의 조건이 만족되어야 한다.</br>
</br>
보석들은 1번 보석부터 N번 보석까지가 차례대로 놓여 있고, 화영이는 1번 보석이 놓여 있는 곳부터 N번 보석이 놓여 있는 곳까지 순서대로 이동한다.</br>
그런데 보석들 사이사이에는 함정이 설치되어 있어서 보석을 줍다가 도중에 뒤로 돌아갈 수는 없다. 따라서 화영이는 보석이 놓여 있는 위치에서 보석을</br>
줍거나 혹은 그냥 지나치고 다음 보석이 있는 위치로 이동하게 된다.</br>
유적에는 함정뿐 아니라 경보 장치도 설치되어 있다. 이 장치는 유적에 들어온 사람이 보석을 주우면 침입자로 간주하고, 침입자가 </br>
보석 줍기를 멈추는 순간 유적을 무너뜨리도록 설계되어 있다. 단, 이 경보 장치는 수를 잘 세지 못하기 때문에 M(1≤M≤N)개 이상의 보석을 연속으로</br>
주우면 헷갈려서 유적을 조금 늦게 무너뜨린다. 따라서 보석을 줍기 시작하면 그 위치에 있는 보석을 포함하여 M개 이상의 보석을 연속적으로 주워야 하고, </br>
보석 줍기를 한 번 멈춘 후에는 다른 보석을 주울 틈도 없이 서둘러서 유적을 빠져나와야 한다.</br>
보석들은 무겁기 때문에, 기왕에 보석을 주워 가는 것이라면 가급적 비싼 보석들로 주워가려 한다. 즉, 주운 보석들의 가치의 총 합을 최대로 하려 한다. </br>
단, 일부 보석들의 가치는 음수일 수도 있다.</br>
보석들의 개수가 매우 많기 때문에, 화영이는 이 문제를 컴퓨터를 이용하여 풀기로 하였다. 보석들에 대한 정보가 주어졌을 때, </br>
위의 조건들을 만족하면서 이동할 때 얻을 수 있는 가치의 총 합의 최댓값을 구하는 프로그램을 작성하시오.</br>

## 코드
```c++
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>
#include <cstring>
using namespace std;
int main(void)
{
	int N, M, tmp = 0, psum[100001], ans = 0;
	scanf("%d %d", &N, &M);
	psum[0] = 0;
	for (int i = 1; i <= N; i++) {
		int num;
		scanf("%d", &num);
		psum[i] = tmp += num;
	}

	tmp = 0;
	for (int i = M; i <= N; i++) {
		tmp = min(tmp, psum[i - M]);
		ans = max(ans, psum[i] - tmp);
	}
	printf("%d\n", ans);
	return 0; 
}
```

## 풀이

dp + 구간합문제 </br>
구간합이란 N개의 배열에서 i번째에서 j번째 까지의 합을 말한다. 구간합을 구하지 않고 구해본다면 </br>

```c++
prefixSum[0] = array[0];
for(int i=1; i<N; i++){
  for(int j=i; j<N; j++){
    prefixSum[i] = prefixSum[i - 1] + array[j];
  }
}
```

최악의 경우 O(N ^ 2) 의 시간복잡도를 예상할 수 있다. </br>
미리 구간합을 구할경우 O(1)의 속도로 구할 수 있다. </br>
A,B 까지 구간합은 다음 점화식으로 구할 수 있다. </br>

</br>
> A, B번째까지 구간합 = prefixsum[B] - prefixsum[A - 1]
</br>

최대 보석을 주워야 하니까 배열을 순회하면서 가장 낮은 값을 빼줘야 한다. </br>
즉 다음의 코드는 </br>

```c++
for (int i = M; i <= N; i++) {          <-- A 부터 B번째 까지 합을 구한다면
		tmp = min(tmp, psum[i - M]);        <-- M개 이상 구간합에서 가장 낮은 A번째 값을 구하는 것
		ans = max(ans, psum[i] - tmp);      <-- 위 점화식으로 p[B] - p[A-1] 가장 큰 값을 구하는 것
}
```

구간합이란 알고리즘을 또 알아서 좋았다.
