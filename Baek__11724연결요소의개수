/*
방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.

dfs가 아닌 bfs로 구현 해봄
*/

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
#define MAX 1001
using namespace std;
int N, M;
int Map[MAX][MAX];
bool check[MAX];
int result = 0;

void Search(int start)
{
    queue<int>q;
    check[start] = true;
    q.push(start);

    while(!q.empty()){

        for (int i = 1; i <= N; i++){
            if (Map[q.front()][i] == 1 && !check[i]){
                check[i] = true;
                q.push(i);
            }
        }
        q.pop();
    }
    result++;
}

int main(void)
{
    int x,y;
    scanf("%d %d", &N, &M);

    for(int i=0; i<M; i++){
        scanf("%d %d", &x, &y);
        Map[x][y] = 1;
        Map[y][x] = 1;
    }
    
    fill(check,check + N,false);

    for (int i = 1; i <= N; i++){
        
        if(!check[i]){    // 아직 탐색하지 않은 정점이 있다면
            Search(i);    // 함수가 몇번호출되냐에 따라 연결그래프의 개수가 나옴
        }
    }

    printf("%d",result);
    return 0;
}
